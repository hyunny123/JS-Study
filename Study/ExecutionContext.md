# 실행 컨텍스트

자바스크립트는 동기적으로 처리된다.

- 한번에 한줄 순서대로 실행된다.
- 그러나 가끔 비동기적인 처리도 가능하다.
  예) setTimeout, 이벤트리스너, ajax함수 사용시

# 실행 컨텍스트

## Execution Context (실행 컨텍스트)

- 자바스크립트 엔진을 실행 -> 콜 스택이라는 통에 전역 실행 컨텍스트(Grobal EC)를 담는다.
- 실행컨텍스트에는 레코드와 아우터가 담겨있다.
- 함수 A를 호출할 경우 함수 A의 실행 컨텍스트를 생성해서 또 콜 스택에 담는다.
- 콜 스택에서는 가장 최근에 추가 된 실행 컨텍스트만 활성화 된다.(위에서 내려다 보이는 실행 컨텍스트만 실행)
- 만약 함수 A에서 함수 B가 호출되면 또 실행 컨텍스트를 담는다.
- 함수 B의 실행을 마치고 함수 B가 종료되면 실행 컨텍스트가 사라진다.
- 그럼 함수 A로 돌아갈 수 있다. A 또한 실행을 마치고 나면 컨텍스트가 사라진다.
- 그래서 전역에 있는 코드가 마지막 라인까지 모두 실행되면 전역 실행 컨텍스트도 사라진다.

---

### Record - js 호이스팅

- 선언 라인 전에도 에러가 나지 않고 변수를 참조할 수 있는 현상을 선언문이 마치 최상단에 올려진듯 하다고 해서 호이스팅 현상이라고 한다.
- 호이스팅(Hoisting) : 선언문이 마치 최상단에 끌어올려진 듯한 현상
- 물리적으로 끌어올린것이 아니라, 자바스크립트 엔진이 먼저 전체 코드를 스캔하고 변수 같은 정보를 실행컨텍스트 어딘가에 미리 기록해놓기 떄문이다.
- 이때 기록해 두는 곳이 바로 레코드이다!!
- 레코드는 ? 환경 레코드(Environment Record) : 식별자와 식별자에 바인딩된 값을 기록해두는 객체

1.  변수 호이스팅 (Variable Hoisting)
    var
    let, const

- 자바스크립트 코드를 실행하면 우선 전역 실행 컨텍스트 한칸을 생성해서 콜스택에 넣는다.
- 그 후 전체적으로 스캔하면서 선언할게 있는지 찾아보고 있다면 먼저 선언해둔다.
- 이처럼 본격적인 실행에 앞서 스캔하고 준비하는 단계를 "생성단계"라고 한다.

1. 생성 단계(Creation Phase) :Execution Context 생성 => 선언문만 실행해서 환경레코드에 기록한다.

2. 실행 단계(Execution Phase) : 선언문 외 나머지 코드 순차적으로 실행 => 환경레코들를 참조하거나 업데이트.

- 우선 먼저 콘솔을 찍게 되면 바인딩 된 값이 없으니까 undefined로 나올 것임.
- 이를 출력하면 변수에 바인딩 된 값이 무엇인지 알아야한다.
- 자바 스크립트 엔진은 현재 활성화된 실행컨덱스트 내에 환경레코드를 보고 이미 기록된 값을 참조해서 값을 출력함.
- 두번째 줄이 선언된 값이 있다면 그것은 아까 생성단계에서 했으니, 이 라인의 할당만 실행해준다.

🙋‍♀️ var 가 아니라 const 였다면 어떤 결과가 출력되었을까?

- 이 경우에는 엔진이 식별자를 기록해두긴 하지만 값을 초기화 하지는 않는다. 따라서 선언문 이전에 변수를 참조하려고 하면 reference Error 발생한다. 자바스크립트 엔진이 변수의 값을 읽어 올 수 없었기 때문이다.

* 일시적 사각지대(TDZ : Temporal Dead Zone)

- let 또는 const로 선언했을시, 선언 이전에 식별자를 참조할 수 없는 구역

var로 변수를 선언한 경우에는 선언과 초기화가 동시에 이루어진다.

1. 선언(Declaration): 메모리 공간을 확보하고 식별자와 연결 {A }
2. 초기화(Initialization) : 식별자에 암묵적으로 undefined 값 바인딩 {A: undefined}

반면 변수를 let,const로 선언한다면
값을 undefined로 초기화 두지 않습니다. 할당문 직전까지 변수에 아무런 값이 담기지 않고 유효한 값을 읽어 올 수 없다. 이러한 동작때문에 일시적 사각지대가 생긴다.

2.  함수 호이스팅 (Function Hoisting)

- 자바스크립트에서는 함수를 변수에다가 담을 수 있다.
- var 키워드에 함수를 담아 선언문 이전에 실행하려고 한다면, 환경레코드에 기록되어있는 값은 undefined이고, undefined라는 데이터 타입은 함수와 달리 호출될 수 없기 때문에 타입 에러가 발생한다.
- 같은 함수를 const 키워드로 선언하면 아직 환경레코드에 기록된 값이 없어서 reference error 발생.

이렇게 변수에 함수를 담아서 함수를 선언하는 방식을 함수 표현식(Function Expression)이라 하는데,
함수를 변수에 담고 있기때문에 앞서 살펴본 변수 호이스팅과 똑같이 동작한다.

🙋‍♀️ 변수에 함수를 담지않고 function 키워드로 선언할 경우는?

- 자바스크립트 엔진이 함수의 선언과 동시에 완성된 함수 객체를 생성해서 환경레코드에 기록해둔다.
- 그리고 스터디 함수가 실행하면 에러없이 실행된다.
- 이렇게 변수에 담지않고 함수 선언문 방식으로 선언한 함수의 경우에는 선언과 동시에 함수가 생성된다는 점이 큰 특징이다. 참고로 이방식을 사용하면 선언 전에도 함수를 사용할 수 있게돼서 사용을 지양하고자 하는 목소리도 있다.
  함수 선언문(Function Declaration): 선언과 동시에 함수가 생성되어 선언 전에도 함수를 사용할 수 있음.

✅ 함수 표현식과 함수 선언문 두 경우에 환경레코드를 살펴보면 두가지의 차이점을 잘 정리해 둘 수 있다.

- 함수 표현식은 var 키워드 일때 환경 레코드 값을 undefined로 초기화 해두는데 undefined를 호출하려고 해서 type Error가 났었고, let const일때는 환경레코드에 값을 초기화해두지 않아서 참조하려 하니까 reference Error가 났었다.
- 함수 선언문은 선언과 동시에 함수 생성을 마치고 온전하게 환경레코드에 저장해두기 때문에 선언라인 전에도 함수를 호출 할 수 있다.

### Outer - js 스코프 체이닝

- 외부 환경 참조 (Outer Environment Reference ) : 바깥 Lexical Environment를 가리킴
- 단순화 실행컨택스트에서 단순화한 레코드와 아우터를 합치면 Lexical Environment라고 하고, 렉시컬 환경 또는 정적 환경이라고 말한다.

let lamp = false;
console.log (lamp);

- 자바스크립트 엔진은 현재 활성화된 실행컨텍스트의 환경레코드를 보고 램프의 값을 쉽게 결정해낸다.

let lamp = false;
fuction goTo2F(){
let lamp = true;
console.log (lamp);
}
goTo2F();

- goTo2F라는 함수를 넣으면 함수선언문 방식이라 선언하는 동시에 환경레코드에 생성된 함수가 통째로 기록 될테고,
  이 함수를 실행하면 새로운 실행컨텍스트가 생성됩니다. 매개변수가 있다면 그것도 환경레코드에 기록하겠지만, 없으미 넘어가서 lamp를 기록합니다. 그리고 lamp값을 출력하려고 환경레코드를 보니 불이 켜진 램프와 불이 꺼진 램프 두개가 있다. 자바스크립트는 램프의 값을 어떤걸로 할지 고민하게 된다. 이런상황에서 변수나 함수의 값을 결정해내는 것을 식별자 결정이라고 한다.

#### 식별자 결정 (Identifier Resolution) : 코드에서 변수나 함수의 값을 결정하는 것

앞에서도 자바스크립트 엔진이 어떤 식별자의 값을 결정하는 일을 반복하고 있다는 것을 인지하고 있었을 것이다.

#### 콜 스택 안에 동일한 식별자가 여럿일 때 자바스크립트 엔진이 어떻게 outer를 활용해서 의사결정을 하는지 알아보자.

let lamp = false;
fuction goTo2F(){
let lamp = true;
funcion goTo3F(){
let pet = 'puppy';
console.log(pet);
console.log(human);

}
}
goTo3F();

- 다시 실행컨텍스트를 실행하고, 자바스크립트 엔진은 새로 생성된 실행 컨텍스트에 바깥 렉시컬 환경으로 돌아갈 수 있는 outer(사다리)를 남겨놓습니다. 이제 필요한 경우에 이전 샐행 컨텍스트의 환경레코드에 저장된 식별자도 참조 할수 있게 되었다.
- 이어서 goTo2F 함수가 실행된다. goTo2F 안에서 다시 goTo3F 함수가 호출된다. 함수가 호출되면 또 실행컨텍스트가 새로 생성되고, 이전 렉시컬 환경을 가르키는 outer를 현재 실행컨텍스트에 저장한다.
- goTo3F에서는 펫을 생성한다. 펫의 값을 출력하려고 하면, 자바스크립트 엔진은 pet의 값을 결정하기 위해 환경레코드를 본다. 콜 스택을 통틀어서 pet이 하나밖에 없긴 하지만 원칙적으로 현재 활성화된 실행컨텍스트의 환경레코드를 먼저 본다. pet puppy 출력한다.

🙋‍♀️근데 여기에서 뜬금없이 human를 찾는다면?

- 현재 활성화된 실행컨텍스트의 환경레코드를 보아도 human는 없다.
- 이럴 경우, 자바스크립트 엔진은 outer가 가리키는 바깥 렉시컬 환경으로 가서 human를 찾기 시작합니다.
- 계속 반복하면서 outer를 타고 바깥 렉시컬 환경으로 갑니다. 전역컨텍스트 = 최상위 컨텍스트이기에 거기에도 없으면, 없는 식별자를 참조하려고 했기때문에 reference error를 보낸다.

let lamp = false;
fuction goTo2F(){
let lamp = true;
funcion goTo3F(){
let pet = 'puppy';
console.log(pet);
console.log(lamp);
}
}
goTo3F();

- 현재 활성화된 실행컨텍스트에는 lamp가 없어서 outer가 가리키는 바깥 렉시컬 환경으로 가서 다시 lamp를 찾게 됩니다. 그리고 켜져있는 램프를 찾아서 값을 on으로 출력한다. 여기에서 주의해야 할 점은 2층에서 이미 램프를 찾았기때문에 더이상 일층으로 내려가서 찾아보지 않는다는 점이다.
- 이층의 램프와 1층의 램프가 같은 이름이기 때문에, 즉, 식별자가 같기때문에 1층의 램프가 켜져있는지 꺼져있는지는 2층에서도, 3층에서도 절대 알 수가 없다.
- 이렇게 동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상을 "변수 섀도잉(Variable Shadowing)"이라고 한다.

#### 변수 섀도잉(Variable Shadowing)

- 동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상

현재 실행될 수 있느 실행컨텍스트의 갯수는 오직 한개이지만, 이전 렉시컬 환경을 가리키는 outer로 타고타고 갈 수 있기 때문에, 3층에 없으면, 2층으로 가서 찾고, 2층에 없으면 1층으로 가서 찾을수 있었다.
이렇게 식별자를 결정할 떄 활용하는 스코프들의 연결리스트를 "스코프 체인"이라고 한다.

#### 스코프 체인(Scope Chain)

식별자를 결정할 때 활용하는 스코프들의 연결리스트
식별자를 결정하기 위해 타고 타고 가서 찾는 과정 자체를 스코프체이닝이라고 한다.

---

### 실행컨텍스트 정리

- 코드를 실행하는데 필요한 환경을 제공하는 객체
- 환경 : 코드 실행에 영향을 주는 조건이나 상태
- 코드를 실행할때 식별자를 더욱 효율적으로 결정하기위한 수단으로써 필요한 정보를 한데 모아 제공하는 객체
